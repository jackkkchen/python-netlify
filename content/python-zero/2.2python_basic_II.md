---
title: 2.2 Data Types and Variables
description: Notes for Python beginners
navigation:
index: 4
icon: i-ph-info-duotone
---

### 1.1 Data Types

Python supports multiple data types, with the four most basic being:

- Integer: `int`, e.g., `1`, `100`, `-8080`, `0`
- Float: `float`, e.g., `1.23`, `-9.01`, `1.23e9`, `3.14e-10`
- String: `str`, e.g., `'abc'`, `'xyz'`, `'123'`
- Boolean: `bool`, including `True` and `False`

> [!Note]
> In Python, when expressing strings, you need to enclose the string content with single quotes `'` or double quotes `"`. Additionally, for multi-line strings, you can use triple single quotes `'''` or triple double quotes `"""`.

To check the data type, you can use the `type()` function:

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
print(type(1))
print(type(1.23))
print(type('hello'))
print(type(True))
```

::

### 1.2 Variables

In Python, variables are used to store data, and variable names are labels for the data. You can think of variables as boxes that hold things, with the box's name being the variable name and the contents being the data. In Python, we use `=` to assign values to variables, i.e., store the data on the right side of `=` into the variable on the left side of `=`.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
a = 1
b = 1.23
c = 'hello'
d = True

print(a)
print(b)
print(c)
print(d)
```

::

When naming variables, you need to follow these rules:

- Variable names can only contain letters, numbers, and underscores `_`, and cannot start with a number.
- Variable names cannot contain spaces and cannot use Python's keywords, such as `if`, `else`, `for`, etc.
- Variable names are case-sensitive, e.g., `a` and `A` are two different variables.

Additionally, to develop good programming habits, variable names should be descriptive to understand the purpose of the variable. For example, if we want to store a person's age, we can use the variable name `age` instead of `a`.

You may have noticed that when defining variables, we are not flexible enough. For example, we want each user to enter their name and then output `Hello, xxx`. At this point, we need to use the `input()` function (functions will be introduced in detail later) to receive the user's input.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
input('What is your name? ')
print('Hello,')
```

::

Did you notice that we entered the name but did not output the name? This is because we did not store the user's input into a variable. We need to store the user's input into a variable and then output it.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
name = input('What is your name? ')
print('Hello,', name)
```

::

Observing the above example, it is easy to see that when using the `print()` function to output, we can output multiple contents at once, just separate them with a comma `,`. In fact, besides using `,`, we can also use `+` to concatenate multiple strings.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
first_name = input('What is your first name? ')
last_name = input('What is your last name? ')
print('Hello,', first_name, last_name)
print('Hello, ' + first_name + ' ' + last_name)
```

::

### 1.3 Operators

Python supports multiple operators that can be used to manipulate various data types. First, let's look at arithmetic operators, including addition `+`, subtraction `-`, multiplication `*`, division `/`, modulus `%`, exponentiation `**`, and floor division `//`. These operators function and are used the same way as in mathematics.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
print(1 + 2)
```

::

Besides directly operating on numbers, we can also operate on variables.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
a = 1
b = 2
c = a + b
print(a, '+', b, '=', c)
```

::

In Python, we can also use operators to modify the value of a variable. For example, if we have a variable `x` and we want to add 1 to the value of `x`, we can use `x = x + 1`.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
x = 1
x = x + 1
print(x)
```

::

In the above code, `x = x + 1` can be abbreviated as `x += 1`, which is a shorthand provided by Python. This shorthand applies to all operators, such as `x -= 1`, `x *= 1`, `x /= 1`, `x %= 1`, `x **= 1`, `x //= 1`.

The precedence of these operators is the same as in mathematics, i.e., multiplication and division before addition and subtraction. If there are multiple operators, you can use parentheses `()` to change the order of operations.

Similarly to mathematical calculations, we can use the `%` operator to determine whether a number is even or odd. If a number divided by 2 has a remainder of 0, it is even; otherwise, it is odd.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
x = 10
if x % 2 == 0:
    print('The number is even.')
else:
    print('The number is odd.')
```

::

Modifying the above program, we can create an interesting little exercise: a lazy calculator that accepts three inputs:

- Two numbers `a` and `b`
- An operator `op`, which can be `+`, `-`, `*`, `/`, `%`, `**`, `//`

The lazy calculator has some conditions:

- It can only perform calculations if both `a` and `b` are even numbers between 1 and 9; otherwise, it will complain: "This calculation is too difficult for me."

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
a = int(input("Enter Number a: "))
b = int(input("Enter Number b: "))
operand = input("Enter operand")

if a < 1 or a > 9:
    print("This is too complicated for me")

elif operand == "+":
    print(a + b)

elif operand == "-":
    print(a - b)

elif operand == "%":
    print(a % b)

elif operand == "/":
    print(a / b)

else:
    print("Invalid operand")
```

::

Additionally, the addition and multiplication operators in arithmetic operations have a special use, i.e., string concatenation. In Python, we can use the `+` operator to concatenate strings and the `*` operator to repeat strings.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
print('hello' + 'world')
print('hello' * 3)
```

::

In addition to arithmetic operators, Python also supports comparison operators, including equal `==`, not equal `!=`, greater than `>`, less than `<`, greater than or equal to `>=`, and less than or equal to `<=`. These operators are used to compare the size of two values, and the result is a boolean value, either `True` or `False`.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
print(1 == 2)
print(1 != 2)
print(1 > 2)
print(1 < 2)
print(1 >= 2)
print(1 <= 2)
```

::

### 1.4 Type Conversion

Sometimes, the data type of a variable is not what we want, and we need to convert the data type of the variable to the desired data type, which may cause some issues.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
a = '1'
b = '2'
print(a + b)
```

::

In the above example, the result of `1 + 2` is `3`, but the result of `a + b` is `12` because the data type of `a` and `b` is string, and the `+` operator concatenates strings. To solve this problem, we need to convert the data type of `a` and `b` to integers.

In Python, we can use the `int()` function to convert an object to an integer, the `float()` function to convert an object to a float, and the `str()` function to convert an object to a string. For the above example, we can convert `a` and `b` to integers and then perform the operation.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
a = '1'
b = '2'
print(int(a) + int(b))
```

::

When performing type conversion, note that if the object cannot be converted to the specified data type, an exception will be raised. For example, if we convert the string `'hello'` to an integer, an exception will be raised.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
a = 'hello'
print(int(a))
```

::

> [!Note]
> Float
>
> A float is a real number with a decimal point. For example, `1.23` and `3.14` are floats. Floats support arithmetic operations like integers, but float operations may have errors because the internal representation of floats in a computer is not precise. For example, the result of `0.1 + 0.2` is not `0.3` but an approximate value. Therefore, when performing operations on floats, we can use the `round()` function to round the result.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
a = (2/3)
print(a)
print(round(a))
print(round(a, 2))
```

::

## 2. Conditional Statements

In programming, we often need to execute different code based on conditions, which requires conditional statements. The most basic conditional statement in Python is the `if` statement, which is used to determine whether a condition is true. If it is true, the code block in the `if` statement is executed; otherwise, it is not executed.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
x = int(input('Please enter an integer: '))
if x > 0:
    print('The number is positive.')
```

::

In the above example, we use the `input()` function to receive an integer input from the user and then determine whether the integer is greater than 0. If it is greater than 0, it outputs `The number is positive.`. Now, let's look at a more complex example to determine whether an integer is positive, negative, or zero.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
x = int(input('Please enter an integer: '))
if x > 0:
    print('The number is positive.')
if x < 0:
    print('The number is negative.')
if x == 0:
    print('The number is zero.')
```

::

In the above example, we use three `if` statements to determine whether the integer `x` is greater than 0, less than 0, or equal to 0. Although this meets our needs, the code is redundant because an integer cannot be both greater than 0 and less than 0. To solve this problem, we can use the `if-elif` statement. `elif` is short for `else if` and is used to determine multiple conditions.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
x = int(input('Please enter an integer: '))
if x > 0:
    print('The number is positive.')
elif x < 0:
    print('The number is negative.')
elif x == 0:
    print('The number is zero.')
```

::

In the `if-elif` statement, when the first condition is true, the corresponding code block is executed, and the entire `if-elif` statement is exited, without executing the subsequent conditions. If the first condition is false, the next condition is checked until a true condition is found, and the corresponding code block is executed. If all conditions are false, no code block is executed. If multiple conditions are true, only the code block of the first true condition is executed.

For the above example, we also find that there is no need to perform the third check because when the integer `x` is greater than 0, it cannot be less than 0 or equal to 0. To further simplify the code, we can use the `if-elif-else` statement. `else` is used to handle all other cases.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
x = int(input('Please enter an integer: '))
if x > 0:
    print('The number is positive.')
elif x < 0:
    print('The number is negative.')
else:
    print('The number is zero.')
```

::

From the above example, we can summarize the following rules:

- The `if` statement is used to determine whether a condition is true. If it is true, the code block in the `if` statement is executed.
- There can be multiple `elif` statements to determine multiple conditions.
- If all conditions are false, the `else` statement can be used to execute the code block in the `else` statement.
- If each condition to be checked is unrelated, multiple `if` statements can be used; if the conditions are mutually exclusive, the `if-elif-else` statement can be used.

## 3. Logical Operators

In conditional statements, we often need to determine multiple conditions, which requires logical operators. Python has three logical operators: `and`, `or`, and `not`. These operators are used to combine multiple conditions.

Semantically, `and` means "and", `or` means "or", and `not` means "not". Logical operators are usually used in conditional statements to determine multiple conditions.

- `and` operator: The result is true if both conditions are true; otherwise, it is false.
- `or` operator: The result is true if at least one of the conditions is true; otherwise, it is false.
- `not` operator: The result is false if the condition is true; the result is true if the condition is false.

Let's look at an example to determine whether an integer is greater than 0 and less than 10.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
x = int(input('Please enter an integer: '))
if x > 0 and x < 10:
    print('The number is between 0 and 10.')
else:
    print('The number is not between 0 and 10.')
```

::

Here, we use the `and` operator to combine two conditions. Only when both conditions are true is the result true. If `x` does not satisfy either of these conditions, the code block in the `else` statement is executed.

Let's slightly modify the above example to determine whether an integer is less than 0 or greater than 10.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
x = int(input('Please enter an integer: '))
if x < 0 or x > 10:
    print('The number is less than 0 or greater than 10.')
else:
    print('The number is between 0 and 10.')
```

::

Here, we use the `or` operator to combine two conditions. As long as at least one of the conditions is true, the result is true. If `x` satisfies either of these conditions, the code block in the `if` statement is executed.

Finally, let's look at an example using the `not` operator to determine whether an integer is not equal to 0.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
x = int(input('Please enter an integer: '))
if not x == 0:
    print('The number is not zero.')
else:
    print('The number is zero.')
```

::

Here, we use the `not` operator to negate the condition, i.e., when the condition is true, the result is false; when the condition is false, the result is true. If `x` is not equal to 0, the code block in the `if` statement is executed; otherwise, the code block in the `else` statement is executed.

The precedence of these operators is `not` > `and` > `or`. If there are multiple logical operators, parentheses `()` can be used to change the order of operations.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
x = -5
y = 10
z = 5

# Without parentheses
if x > 0 and y > 0 or z > 0:
    print('Condition without parentheses is True.')
else:
    print('Condition without parentheses is False.')

# With parentheses
if x > 0 and (y > 0 or z > 0):
    print('Condition with parentheses is True.')
else:
    print('Condition with parentheses is False.')
```

::

In the above example, we use `and` and `or` operators to combine multiple conditions:

- Without parentheses: Since `and` has a higher precedence than `or`, `x > 0 and y > 0` is evaluated first, resulting in False. Then `False or z > 0` is evaluated, and since `z > 0` is True, the entire condition is True.
- With parentheses: The condition inside the parentheses is evaluated first, i.e., `y > 0 or z > 0`, which is True. Then `x > 0 and True` is evaluated, resulting in False. So the entire condition is False.

## 4. Data Structures

When we need to store multiple pieces of data, a good way is to use data structures. Python has four basic data structures: lists (`list`), tuples (`tuple`), sets (`set`), and dictionaries (`dict`). They have two basic properties: whether they are ordered and whether they are mutable. Ordered means that the elements in the data structure are arranged in a certain order, and each object has a clear position. For ordered data structures, we can refer to the objects as the first, second, third, etc. Mutable means that the elements in the data structure can be modified. If they can be modified, we call the data structure mutable; if not, we call it immutable.

- List (`list`): Ordered, mutable, used to store multiple ordered elements.
- Tuple (`tuple`): Ordered, immutable, used to store multiple ordered elements.
- Set (`set`): Unordered, mutable, used to store multiple unordered elements.
- Dictionary (`dict`): Unordered, mutable, used to store multiple key-value pairs.

Typically, we use lists to store multiple elements, tuples to store multiple immutable elements, sets to store multiple unique elements, and dictionaries to store multiple key-value pairs.

### 4.1 Lists

Lists are the most commonly used data structure in Python, used to store multiple ordered elements. Lists are represented by square brackets `[]`, with elements separated by commas `,`. The elements in a list can be of any data type, including integers, floats, strings, booleans, and even other lists.

> [!Note]
> Although lists support storing elements of different types, it is generally not recommended to store different types of elements in a list, as it makes the code difficult to understand.

Here is a simple example of a list.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
numbers = [1, 2, 3, 4, 5]
print(numbers)
print(type(numbers))
print()
my_list = [1, 2.3, 'hello', True, [1, 2, 3]]
print(my_list)
print(type(my_list))
```

::

Since lists are an ordered data structure, we can use indexing to access elements in the list. In Python, indexing starts from 0, i.e., the index of the first element is 0, the index of the second element is 1, and so on. Additionally, we can use negative indexing to access elements from the end of the list, i.e., the index of the last element is -1, the index of the second last element is -2, and so on.

To use indexing, add square brackets `[]` after the list name and fill in the index value, i.e., `list[index]`.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
my_list = ['apple', 'banana', 'cherry', 'date', 'elderberry']
print(my_list[0])
print(my_list[1])
print(my_list[-1])
```

::

In Python, we can also use slicing to access multiple elements in a list. To use slicing, add square brackets `[]` after the list name and fill in the start index, end index, and step (step defaults to 1 and can be omitted), separated by colons `:`, i.e., `list[start:end:step]`. Slicing returns a new list containing all elements from the start index to the end index, but not including the end index.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
my_list = ['apple', 'banana', 'cherry', 'date', 'elderberry']
print(my_list[1:3])
print(my_list[:3])
print(my_list[3:])
print(my_list[1:4:2])
```

::

Additionally, since lists are mutable, we can modify elements in the list using indexing and assignment statements, i.e., `list[index] = value`.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
my_list = ['apple', 'banana', 'cherry', 'date', 'elderberry']
my_list[1] = 'blueberry'
print(my_list)
```

::

By flexibly using list indexing, we can swap two elements in a list.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
my_list = ['apple', 'banana', 'cherry', 'date', 'elderberry']
my_list[1], my_list[2] = my_list[2], my_list[1]
print(my_list)
```

::

Additionally, we can use the `append()` method to add new elements to the list and the `remove()` method to remove specified elements.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
my_list = ['apple', 'banana', 'cherry', 'date', 'elderberry']
my_list.append('fig')
print(my_list)
my_list.remove('banana')
print(my_list)
```

::

### 4.2 Tuples

Tuples are another ordered data structure in Python. The biggest difference from lists is that tuples are immutable, i.e., the elements in a tuple cannot be modified. Tuples are represented by parentheses `()`, with elements separated by commas `,`.

The usage of tuples is similar to lists. We can use indexing and slicing to access elements in a tuple, but we cannot modify the elements in a tuple.

Here is a simple example of a tuple.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
my_tuple = (1, 2, 3, 4, 5)
print(my_tuple)
print(type(my_tuple))
```

::

Similar to lists, we can use indexing and slicing to access elements in a tuple.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
my_tuple = ('apple', 'banana', 'cherry', 'date', 'elderberry')
print(my_tuple[0])
print(my_tuple[1])
print(my_tuple[-1])
print(my_tuple[1:3])
```

::

However, we cannot modify elements in a tuple, otherwise an exception will be raised.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
my_tuple = ('apple', 'banana', 'cherry', 'date', 'elderberry')
my_tuple[1] = 'blueberry'
```

::

> [!Note]
> In Python, strings can be considered a special type of tuple, i.e., strings are immutable ordered sequences. Therefore, strings also support indexing and slicing operations, but characters in a string cannot be modified.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
my_string = 'hello'
print(my_string[0])
print(my_string[1:3])
```

::

### 4.3 Sets

Sets are an unordered data structure in Python, used to store multiple unique elements. Sets are represented by curly braces `{}`, with elements separated by commas `,`.

An important feature of sets is that the elements in a set are unique, i.e., duplicate elements are not allowed in a set.

Here is a simple example of a set.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
my_set = {1, 2, 3, 4, 5}
print(my_set)
print(type(my_set))
```

::

Unlike lists and tuples, sets are unordered, so we cannot use indexing and slicing to access elements in a set. However, we can use the `in` operator to check if an element is in the set.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
my_set = {1, 2, 3, 4, 5}
print(1 in my_set)
print(6 in my_set)
```

::

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
my_set = {1, 2, 3, 4, 5}
print(my_set[0])
```

::

We can use the `add()` method to add new elements to the set and the `remove()` method to remove specified elements.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
my_set = {1, 2, 3, 4, 5}
my_set.add(6)
print(my_set)
my_set.remove(6)
print(my_set)
```

::

Since the elements in a set are unique, adding duplicate elements to the set will have no effect.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
my_set = {1, 2, 3, 4, 5}
my_set.add(6)
print(my_set)
my_set.add(6)
print(my_set)
```

::

As you can see, adding the element `6` a second time does not add a new element to the set because the set already contains the element `6`.

We can use the characteristics of sets to remove duplicates from a list, i.e., remove duplicate elements from a list.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
my_list = [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]
my_set = set(my_list)
print(my_set)
```

::

> [!Note]
> You may have noticed that lists, tuples, and sets can be converted to each other, i.e., we can use the `list()`, `tuple()`, and `set()` functions to convert a list, tuple, or set to another list, tuple, or set. However, note that the converted data structure may lose some information. For example, sets are unordered, so converting to a list or tuple may change the order of elements and lose duplicate elements.

Additionally, we can use the `union()` method to find the union of two sets, the `intersection()` method to find the intersection of two sets, and the `difference()` method to find the difference between two sets.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
set1 = {1, 2, 3, 4, 5}
set2 = {4, 5, 6, 7, 8}
print(set1.union(set2))
print(set1.intersection(set2))
print(set1.difference(set2))
```

::

### 4.4 Dictionaries

Dictionaries are an unordered data structure in Python used to store multiple key-value pairs. Dictionaries are represented by curly braces `{}`, with each key-value pair separated by a colon `:`, and key-value pairs separated by commas `,`.

You can imagine a scenario where you have an English-Chinese dictionary, and you can look up the Chinese meaning by the English word. In this scenario, the English word is the key, and the Chinese meaning is the value. This is the basic structure of a dictionary.

To further understand the concept of key-value pairs, consider the following table:

| Key   | Value                |
|-------|----------------------|
| name  | Alice, Bob, Charlie  |
| age   | 18, 19, 20           |

In this example, `name` and `age` are keys, and `Alice`, `Bob`, `Charlie`, `18`, `19`, and `20` are values. A key-value pair is an element in a dictionary, and a dictionary can have multiple key-value pairs.

Let's look at a simple scenario where we represent the following table using Python data structures:

| Hermione | Harry | Ron | Draco |
|----------|-------|-----|-------|
| Gryffindor | Gryffindor | Gryffindor | Slytherin |

Suppose we first use lists to represent this table, we can do it like this:

```python
students = ['Hermione', 'Harry', 'Ron', 'Draco']
houses = ['Gryffindor', 'Gryffindor', 'Gryffindor', 'Slytherin']
```

We can see that using lists to represent this table can represent the content of the table, but it cannot represent the relationships in the table, i.e., it cannot show that Hermione corresponds to Gryffindor, Harry corresponds to Gryffindor, etc. We can only use indexes to find the corresponding values. This requires us to remember the index of each student to find the corresponding house. When there are many students, this method becomes very cumbersome.

To solve this problem, we can use dictionaries to represent this table, so we can look up the corresponding house by the student's name.

```python
students = {
    'Hermione': 'Gryffindor',
    'Harry': 'Gryffindor',
    'Ron': 'Gryffindor',
    'Draco': 'Slytherin'
}

print(students['Hermione'])
print(students['Harry'])
print(students['Ron'])
print(students['Draco'])
```

In this example, `students` is a dictionary, `'Hermione'`, `'Harry'`, `'Ron'`, and `'Draco'` are keys, and `'Gryffindor'`, `'Gryffindor'`, `'Gryffindor'`, and `'Slytherin'` are values. Using a dictionary, we can look up the corresponding house by the student's name.

Since dictionaries are unordered, we cannot use indexing and slicing to access elements in a dictionary. However, as we see in the example above, we can use keys to access values in a dictionary. Therefore, keys in a dictionary are unique and cannot be duplicated. However, values can be duplicated, i.e., values in a dictionary can be repeated.

Here is a simple example of a dictionary.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
my_dict = {'name': 'Alice', 'age': 18}
print(my_dict)
print(type(my_dict))
```

::

In addition to directly creating dictionaries, we can also use the `dict()` function to initialize an empty dictionary and then add elements using key-value pairs.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
my_dict = dict()
my_dict['name'] = 'Alice'
my_dict['age'] = 18
print(my_dict)
```

::

Additionally, since dictionaries are mutable, we can modify values in a dictionary by accessing keys and using assignment statements to assign new values to elements in the dictionary, i.e., `dict[key] = value`.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
my_dict = {'name': 'Alice', 'age': 18}
my_dict['age'] = 19
print(my_dict)
```

::

We can use the `keys()` method to get all keys in a dictionary, the `values()` method to get all values in a dictionary, and the `items()` method to get all key-value pairs in a dictionary.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
my_dict = {'name': 'Alice', 'age': 18}
print(my_dict.keys())
print(my_dict.values())
print(my_dict.items())
```

::

The keys and values in a dictionary do not have to be of the same data type. Keys can be any immutable data type, such as integers, floats, strings, tuples, and values can be any data type, such as integers, floats, strings, booleans, lists, tuples, sets, dictionaries.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
my_dict = {1: 'Alice', 2.3: 18, 'name': 'Alice', (1, 2): [1, 2], 'info': {'name': 'Alice', 'age': 18}} 
print(my_dict[1])
print(my_dict[2.3])
print(my_dict['name'])
print(my_dict[(1, 2)])
print(my_dict[(1, 2)][0])
print(my_dict['info'])
```

::

If we have more complex data, we can combine lists and dictionaries. For example, we can use dictionaries to represent information about a student, including name, age, and score, and then store information about multiple students in a list.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
students = [
    {'name': 'Alice', 'age': 18, 'score': 90},
    {'name': 'Bob', 'age': 19, 'score': 85},
    {'name': 'Charlie', 'age': 20, 'score': 80}
]
print(students[0]['name'])
print(students[1]['age'])
print(students[2]['score'])
```

::

Note how we access each student's information. First, we access the student list by index, and at this point, we get a dictionary of a student. Then, we access the student's information by key.

## 5. Functions

### 5.1 Defining Functions

In Python, a function is a reusable block of code that performs a specific task. Functions can accept parameters, perform specific operations, and then return results. We have already encountered some built-in Python functions, such as `print()`, `input()`, `int()`, `float()`, `str()`, `round()`, etc.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
name = input('Please enter your name: ')
print('Hello, ' + name + '!')
```

::

In Python, we can use the `def` keyword to define a function, followed by the function name, parameter list, and a colon `:`, and then write the function's code in the indented block. The parameter list can contain zero or more parameters, separated by commas `,`.

Here is a simple example of a function.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
def greet(name):
    print('Hello, ' + name + '!')

name = input('Please enter your name: ')
greet(name)
```

::

In the above example, we define a function `greet` immediately following the `def` keyword. The parentheses after `greet` contain the function's parameter list, which includes one parameter `name`. The function body prints `Hello, name!`. After defining the function, we call the `greet` function and pass in a parameter `name`.

Note that the function body must be indented. For example, in the above example, `print('Hello, ' + name + '!')` is the function body of `greet` and must be indented.

Typically, we use four spaces for indentation. Indentation is an important concept in Python, used to indicate the beginning and end of a code block. In Python, indentation is mandatory, and incorrect indentation will cause errors in the program.

### 5.2 Function Return Values

In the example from the previous section, the function we defined simply printed a sentence and did not return any result. However, in most cases, we need the function to return a result. If the function cannot return a result, its usefulness is limited.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
def add_and_return(a, b):
    return a + b

def add(a, b):
    print(a + b)

print(f'There is a return value: {add_and_return(1, 2) + 3}')
print(f'There is no return value: {add(1, 2) + 3}')
```

::

We find that the above code will report an error when it runs to the statement `print(f'There is no return value: {add(1, 2) + 3}')` because the function `add` does not have a return value, so it cannot perform the addition operation.

Therefore, we need to use the `return` keyword to return the result of the function. The `return` keyword can be followed by an expression to return the result of the function, or it can be used without an expression to end the execution of the function.

Here is a simple function example.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

result1 = add(1, 2)
result2 = subtract(3, 4)

print(result1)
print(result2)
```

::

In the above example, we defined two functions `add` and `subtract` to calculate the sum and difference of two numbers, respectively. In the function body, we use the `return` keyword to return the calculation result. When calling the function, we assign the return value of the function to the variables `result1` and `result2`, and then print these two variables.

Note that the `return` keyword can only return one value. If you need to return multiple values, you can use data structures such as tuples, lists, or dictionaries.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
def add_and_subtract(a, b):
    return a + b, a - b

result = add_and_subtract(1, 2)
print(result)
```

::

In the above example, we defined a function `add_and_subtract` to calculate the sum and difference of two numbers. In the function body, we use the `return` keyword to return a tuple containing two values. When calling the function, we assign the return value of the function to the variable `result` and then print this variable.

### 5.3 Function Parameters

In Python, function parameters are mainly divided into two types: positional parameters and keyword parameters. Positional parameters are passed based on the position of the parameters when calling the function, while keyword parameters are passed based on the name of the parameters when calling the function.

#### 5.3.1 Positional Parameters

Positional parameters are the parameters declared when defining the function. When calling the function, you need to pass the parameters according to their positions. The number and order of positional parameters must match the parameters declared when defining the function.

Here is a simple example of positional parameters.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
def greet(name, age):
    print(f'Hello, {name}! You are {age} years old.')

greet('Alice', 18)
greet(19, 'Bob')
```

::

In the above example, we defined a function. When calling this function, we need to pass the parameters according to the order of the parameters declared when defining the function. If the number and order of the parameters are incorrect, the program will not execute as expected. For example, when we call `greet(19, 'Bob')`, the program will output `Hello, 19! You are Bob years old.`, which is not what we want.

Therefore, although positional parameters are simple, they are prone to errors, especially when there are many parameters, making it easy to confuse the order of the parameters.

#### 5.3.2 Keyword Parameters

Keyword parameters are passed based on the name of the parameters when calling the function. The advantage of keyword parameters is that you do not need to pass the parameters in order; you only need to specify the name of the parameters.

Here is a simple example of keyword parameters.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
def greet(name, age):
    print(f'Hello, {name}! You are {age} years old.')

greet(name='Alice', age=18)
greet(age=19, name='Bob')
```

::

In the above example, when calling the function `greet`, we used keyword parameters, i.e., we specified the name of the parameters when passing them. This way, we do not need to pass the parameters in order; we only need to specify the name of the parameters. As you can see, in the second call to `greet`, we swapped the order of the parameters, but the program still executed correctly.

## 6. Loops

In programming, loops are a structure that repeatedly executes a set of statements. Loops can help us simplify code and reduce repetitive work. Python has two loop structures: `while` loops and `for` loops.

### 6.1 `while` Loop

The `while` loop is used to repeatedly execute a set of statements as long as the condition is true. The syntax structure of the `while` loop is as follows:

```python
while condition:
    statement1
    statement2
    ...
```

In a `while` loop, the `condition` is first checked. If it is true, `statement1`, `statement2`, etc., are executed. Then the `condition` is checked again. If it is still true, `statement1`, `statement2`, etc., are executed again, and so on, until the `condition` is false, and the loop ends.

Here is a simple example of a `while` loop.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
i = 0
while i < 5:
    print(i)
    i += 1
```

::

In the above example, we defined a variable `i` and then used a `while` loop to print the value of `i` until the value of `i` is greater than or equal to 5. In the loop body, we first print the value of `i` and then increment the value of `i` by 1.

You may have noticed that for a `while` loop, if the loop condition is not restricted, the loop will execute indefinitely, which is called an infinite loop.

```python
# If you run the following code, the program may not end normally. In this case, you can click the stop button in the upper right corner to terminate the program, or use the shortcut key Ctrl + C to terminate the program.
while True:
    print('This is an infinite loop.')
```

An infinite loop is very dangerous because it prevents the program from ending normally and may even cause the system to crash. Therefore, when using a `while` loop, make sure that the loop condition will eventually become false to end the loop.

### 6.2 `for` Loop

In addition to the `while` loop, which requires us to actively set the loop condition, Python also provides the `for` loop, which is used to iterate over elements in a sequence (such as lists, tuples, sets, dictionaries, etc.). The syntax structure of the `for` loop is as follows:

> [!Note]
> Iteration means accessing each element in the sequence one by one. For example, for a list, iteration means accessing each element in the list one by one.

```python
for element in sequence:
    statement1
    statement2
    ...
```

In a `for` loop, `sequence` is a sequence, `element` is each element in the sequence, and `statement1`, `statement2`, etc., are statements that operate on each element.

Here is a simple example of a `for` loop.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
my_list = [1, 2, 3, 4, 5]
for i in my_list:
    print(i)
```

::

In the above example, we defined a list `my_list` and then used a `for` loop to iterate over each element in the list and print the value of each element.

With the `for` loop, we can easily iterate over elements in sequences such as lists, tuples, sets, dictionaries, etc., and perform specific operations, such as summing the elements in a list.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
my_list = [1, 2, 3, 4, 5]
sum = 0
for i in my_list:
    sum = sum + i
print(sum)
```

::

In the above example, we defined a list `my_list` and then used a `for` loop to iterate over each element in the list and add the value of each element to the variable `sum`, and finally print the value of `sum`.

Here is a simple exercise. You can use the knowledge of the `%` operator mentioned earlier and use a `for` loop to print the odd numbers in the list.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
my_list = [1, 2, 3, 4, 5]
for i in my_list:
    if i % 2 != 0:
        print(i)
```

::

Additionally, in a `for` loop, we can use the `range()` function to generate a sequence of integers to iterate over a range of integers. The syntax structure of the `range()` function is as follows:

```python
range(start, stop, step)
```

The `range()` function generates a sequence of integers from `start` to `stop`, with a step size of `step`. `start` is the starting value of the sequence, defaulting to 0; `stop` is the ending value of the sequence, but not including `stop`; `step` is the step size of the sequence, defaulting to 1.

Here is a simple example of a `for` loop using the `range()` function.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
for i in range(5):
    print(i)
```

::

In the above example, `range(5)` generates a sequence of integers from 0 to 5, but not including 5, i.e., the sequence is 0, 1, 2, 3, 4. Then we use a `for` loop to iterate over this sequence and print the value of each element.

We can make the `range()` function a bit more complex, such as generating a sequence of integers from 1 to 10 with a step size of 2.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
for i in range(1, 10, 2):
    print(i)
```

::

The `range()` function is very useful when we want to execute a loop a certain number of times, such as when we want to execute a loop 5 times.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
for i in range(5):
    print('This is the', i + 1, 'time.')
```

::

Or when we want to iterate over the indexes of a list.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
my_list = ['apple', 'banana', 'cherry', 'date', 'elderberry']

for i in range(len(my_list)):
    print(i, my_list[i])
```

::

In the above example, we use `range(len(my_list))` to generate a sequence of integers from 0 to `len(my_list)`, and then use a `for` loop to iterate over this sequence and print the index and value of each element.

Now, you can try combining the `range()` function and the `for` loop to print the sum of the cubes of all odd numbers from 1 to 9 (inclusive).

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
sum = 0
for i in range(1, 10, 2):
    sum = sum + i ** 3
print(sum)
```

::

### 6.3 Loop Control Statements

In loops, it is easy to encounter exceptions caused by special situations, such as infinite loops. To avoid these exceptions, Python provides some loop control statements to control the execution of loops.

- `break` statement: Used to terminate the loop. Even if the loop condition is true, it will immediately exit the loop.
- `continue` statement: Used to skip the remaining statements in the current loop and continue with the next iteration of the loop.
- `pass` statement: Used as a placeholder, indicating that nothing is done. It is usually used to occupy a code block to make the code structure complete.

Here is a simple example of the `break` statement.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
i = 0
while i < 5:
    print(i)
    i += 1
    if i == 3:
        break
```

::

In the above example, we use a `while` loop to print the value of `i`. When the value of `i` is equal to 3, we use the `break` statement to terminate the loop. Therefore, even if the loop condition `i < 5` is satisfied, the loop will immediately exit when the value of `i` is equal to 3.

Here is a simple example of the `continue` statement.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
i = 0
while i < 5:
    i += 1
    if i == 3:
        continue
    print(i)
```

::

In the above example, we use a `while` loop to print the value of `i`. When the value of `i` is equal to 3, we use the `continue` statement to skip the remaining statements in the current loop and continue with the next iteration of the loop. Therefore, when the value of `i` is equal to 3, the value of `i` will not be printed.

Here is a simple example of the `pass` statement.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
i = 0
while i < 5:
    i += 1
    if i == 3:
        pass
    print(i)
```

::

In the above example, we use a `while` loop to print the value of `i`. When the value of `i` is equal to 3, we use the `pass` statement to indicate that nothing is done, and then continue with the next statement. Therefore, when the value of `i` is equal to 3, there will be no change.

## 7. Exception Handling

In programming, an exception is an error that occurs during the execution of a program, which may cause the program to terminate. To prevent the program from terminating, we can use exception handling mechanisms to catch exceptions, allowing the program to continue executing.

In the previous examples, we mentioned that passing a non-numeric string to the `int()` function will raise a `ValueError` exception.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
number = int('abc')
print(number)
```

::

In the above example, passing a non-numeric string `'abc'` to the `int()` function will raise a `ValueError` exception, causing the program to terminate. To prevent the program from terminating, we can use `try` and `except` statements to catch exceptions.

The `try` and `except` statements allow us to catch exceptions in a block of code that may raise an exception and perform specific actions when an exception occurs. The `try` statement is used to wrap the block of code that may raise an exception, and the `except` statement is used to catch the exception and perform specific actions.

Here is a simple example of exception handling.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
try:
    number = int(input('Please enter a number: '))
    print(number)
except ValueError:
    print('An error occurred.')
```

::

In the above code, if we enter an integer, the program will execute normally and print the entered integer. However, if we enter a non-numeric string, the program will raise a `ValueError` exception. In this case, the `except ValueError:` statement will catch the exception (without terminating the program) and print `An error occurred.`.

With exception handling mechanisms, we can handle various exceptions in the program, making the program more robust. For example, we can modify the above code to prompt the user to re-enter a number if a non-numeric string is entered.

::code-mirror-run{:editable="true" maxHeight="20rem" :showInCol="true"}

```python
while True:
    try:
        number = int(input('Please enter a number: '))
        print(number)
        break
    except ValueError:
        print('Please enter a valid number.')
```

::

In the above code, we use a `while True:` loop to continuously prompt the user to enter a number, and then use `try` and `except` statements to catch exceptions. If the user enters a non-numeric string, the program will print `Please enter a valid number.` and then continue to prompt the user to enter a number until a valid number is entered.
